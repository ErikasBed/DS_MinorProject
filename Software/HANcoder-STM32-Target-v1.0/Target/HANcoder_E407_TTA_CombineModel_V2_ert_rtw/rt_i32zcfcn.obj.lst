   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 2
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.file	"rt_i32zcfcn.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.file 1 "rt_i32zcfcn.c"
  19              		.section	.text.rt_I32ZCFcn,"ax",%progbits
  20              		.align	1
  21              		.p2align 2,,3
  22              		.global	rt_I32ZCFcn
  23              		.syntax unified
  24              		.thumb
  25              		.thumb_func
  27              	rt_I32ZCFcn:
  28              	.LVL0:
  29              	.LFB0:
   1:rt_i32zcfcn.c **** /*
   2:rt_i32zcfcn.c ****  * Academic License - for use in teaching, academic research, and meeting
   3:rt_i32zcfcn.c ****  * course requirements at degree granting institutions only.  Not for
   4:rt_i32zcfcn.c ****  * government, commercial, or other organizational use.
   5:rt_i32zcfcn.c ****  *
   6:rt_i32zcfcn.c ****  * File: rt_i32zcfcn.c
   7:rt_i32zcfcn.c ****  *
   8:rt_i32zcfcn.c ****  * Code generated for Simulink model 'HANcoder_E407_TTA_CombineModel_V2'.
   9:rt_i32zcfcn.c ****  *
  10:rt_i32zcfcn.c ****  * Model version                  : 18.12
  11:rt_i32zcfcn.c ****  * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022
  12:rt_i32zcfcn.c ****  * C/C++ source code generated on : Fri Jun  9 15:34:05 2023
  13:rt_i32zcfcn.c ****  *
  14:rt_i32zcfcn.c ****  * Target selection: ert.tlc
  15:rt_i32zcfcn.c ****  * Embedded hardware selection: ARM Compatible->ARM Cortex
  16:rt_i32zcfcn.c ****  * Code generation objectives: Unspecified
  17:rt_i32zcfcn.c ****  * Validation result: Not run
  18:rt_i32zcfcn.c ****  */
  19:rt_i32zcfcn.c **** 
  20:rt_i32zcfcn.c **** #include "zero_crossing_types.h"
  21:rt_i32zcfcn.c **** #include "rtwtypes.h"
  22:rt_i32zcfcn.c **** #include "rt_i32zcfcn.h"
  23:rt_i32zcfcn.c **** #include "solver_zc.h"
  24:rt_i32zcfcn.c **** 
  25:rt_i32zcfcn.c **** /* Detect zero crossings events. */
  26:rt_i32zcfcn.c **** ZCEventType rt_I32ZCFcn(ZCDirection zcDir, ZCSigState *prevZc, int32_T currValue)
  27:rt_i32zcfcn.c **** {
  30              		.loc 1 27 1 view -0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 0
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  28:rt_i32zcfcn.c ****   slZcEventType zcsDir;
  34              		.loc 1 28 3 view .LVU1
  29:rt_i32zcfcn.c ****   slZcEventType tempEv;
  35              		.loc 1 29 3 view .LVU2
  30:rt_i32zcfcn.c ****   ZCEventType zcEvent = NO_ZCEVENT;    /* assume */
  36              		.loc 1 30 3 view .LVU3
  31:rt_i32zcfcn.c **** 
  32:rt_i32zcfcn.c ****   /* zcEvent matrix */
  33:rt_i32zcfcn.c ****   static const slZcEventType eventMatrix[4][4] = {
  37              		.loc 1 33 3 view .LVU4
  34:rt_i32zcfcn.c ****     /*          ZER              POS              NEG              UNK */
  35:rt_i32zcfcn.c ****     { SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_Z2P, SL_ZCS_EVENT_Z2N, SL_ZCS_EVENT_NUL },/* ZER */
  36:rt_i32zcfcn.c **** 
  37:rt_i32zcfcn.c ****     { SL_ZCS_EVENT_P2Z, SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_P2N, SL_ZCS_EVENT_NUL },/* POS */
  38:rt_i32zcfcn.c **** 
  39:rt_i32zcfcn.c ****     { SL_ZCS_EVENT_N2Z, SL_ZCS_EVENT_N2P, SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_NUL },/* NEG */
  40:rt_i32zcfcn.c **** 
  41:rt_i32zcfcn.c ****     { SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_NUL }/* UNK */
  42:rt_i32zcfcn.c ****   };
  43:rt_i32zcfcn.c **** 
  44:rt_i32zcfcn.c ****   /* get prevZcEvent and prevZcSign from prevZc */
  45:rt_i32zcfcn.c ****   const slZcEventType prevEv = (slZcEventType)(((uint8_T)(*prevZc)) >> 2);
  38              		.loc 1 45 3 view .LVU5
  39              		.loc 1 45 59 is_stmt 0 view .LVU6
  40 0000 91F800C0 		ldrb	ip, [r1]	@ zero_extendqisi2
  41              	.LVL1:
  46:rt_i32zcfcn.c ****   const slZcSignalSignType prevSign = (slZcSignalSignType)(((uint8_T)(*prevZc))
  42              		.loc 1 46 3 is_stmt 1 view .LVU7
  47:rt_i32zcfcn.c ****     & (uint8_T)0x03);
  48:rt_i32zcfcn.c **** 
  49:rt_i32zcfcn.c ****   /* get current zcSignal sign from current zcSignal value */
  50:rt_i32zcfcn.c ****   const slZcSignalSignType currSign = (slZcSignalSignType)((currValue) > 0 ?
  43              		.loc 1 50 39 is_stmt 0 view .LVU8
  44 0004 002A     		cmp	r2, #0
  27:rt_i32zcfcn.c ****   slZcEventType zcsDir;
  45              		.loc 1 27 1 view .LVU9
  46 0006 10B5     		push	{r4, lr}
  47              		.cfi_def_cfa_offset 8
  48              		.cfi_offset 4, -8
  49              		.cfi_offset 14, -4
  46:rt_i32zcfcn.c ****   const slZcSignalSignType prevSign = (slZcSignalSignType)(((uint8_T)(*prevZc))
  50              		.loc 1 46 28 view .LVU10
  51 0008 0CF00304 		and	r4, ip, #3
  52              	.LVL2:
  53              		.loc 1 50 3 is_stmt 1 view .LVU11
  54              		.loc 1 50 39 is_stmt 0 view .LVU12
  55 000c 2EDD     		ble	.L25
  56 000e 4FF0010E 		mov	lr, #1
  57 0012 7246     		mov	r2, lr
  58              	.LVL3:
  59              	.L2:
  51:rt_i32zcfcn.c ****     SL_ZCS_SIGN_POS :
  52:rt_i32zcfcn.c ****     ((currValue) < 0 ? SL_ZCS_SIGN_NEG : SL_ZCS_SIGN_ZERO));
  53:rt_i32zcfcn.c **** 
  54:rt_i32zcfcn.c ****   /* get current zcEvent based on prev and current zcSignal value */
  55:rt_i32zcfcn.c ****   slZcEventType currEv = eventMatrix[prevSign][currSign];
  60              		.loc 1 55 3 is_stmt 1 discriminator 4 view .LVU13
  61              		.loc 1 55 17 is_stmt 0 discriminator 4 view .LVU14
  62 0014 184B     		ldr	r3, .L29
  63 0016 0130     		adds	r0, r0, #1
  64              	.LVL4:
  65              		.loc 1 55 17 discriminator 4 view .LVU15
  66 0018 C0B2     		uxtb	r0, r0
  67 001a 03EB8403 		add	r3, r3, r4, lsl #2
  68 001e 0228     		cmp	r0, #2
  69 0020 13F80E30 		ldrb	r3, [r3, lr]	@ zero_extendqisi2
  70              	.LVL5:
  56:rt_i32zcfcn.c **** 
  57:rt_i32zcfcn.c ****   /* get slZcEventType from ZCDirection */
  58:rt_i32zcfcn.c ****   switch (zcDir) {
  71              		.loc 1 58 3 is_stmt 1 discriminator 4 view .LVU16
  72 0024 02D9     		bls	.L26
  73              	.LVL6:
  74              	.L3:
  59:rt_i32zcfcn.c ****    case ANY_ZERO_CROSSING:
  60:rt_i32zcfcn.c ****     zcsDir = SL_ZCS_EVENT_ALL;
  61:rt_i32zcfcn.c ****     break;
  62:rt_i32zcfcn.c **** 
  63:rt_i32zcfcn.c ****    case FALLING_ZERO_CROSSING:
  64:rt_i32zcfcn.c ****     zcsDir = SL_ZCS_EVENT_ALL_DN;
  65:rt_i32zcfcn.c ****     break;
  66:rt_i32zcfcn.c **** 
  67:rt_i32zcfcn.c ****    case RISING_ZERO_CROSSING:
  68:rt_i32zcfcn.c ****     zcsDir = SL_ZCS_EVENT_ALL_UP;
  69:rt_i32zcfcn.c ****     break;
  70:rt_i32zcfcn.c **** 
  71:rt_i32zcfcn.c ****    default:
  72:rt_i32zcfcn.c ****     zcsDir = SL_ZCS_EVENT_NUL;
  73:rt_i32zcfcn.c ****     break;
  74:rt_i32zcfcn.c ****   }
  75:rt_i32zcfcn.c **** 
  76:rt_i32zcfcn.c ****   /* had event, check if zc happened */
  77:rt_i32zcfcn.c ****   if (slZcHadEvent(currEv, zcsDir)) {
  78:rt_i32zcfcn.c ****     currEv = (slZcEventType)(slZcUnAliasEvents(prevEv, currEv));
  79:rt_i32zcfcn.c ****   } else {
  80:rt_i32zcfcn.c ****     currEv = SL_ZCS_EVENT_NUL;
  81:rt_i32zcfcn.c ****   }
  82:rt_i32zcfcn.c **** 
  83:rt_i32zcfcn.c ****   /* Update prevZc */
  84:rt_i32zcfcn.c ****   tempEv = (slZcEventType)(currEv << 2);/* shift left by 2 bits */
  85:rt_i32zcfcn.c ****   *prevZc = (ZCSigState)((currSign) | (tempEv));
  75              		.loc 1 85 11 is_stmt 0 view .LVU17
  76 0026 0A70     		strb	r2, [r1]
  77 0028 0020     		movs	r0, #0
  78              	.LVL7:
  79              	.L7:
  86:rt_i32zcfcn.c ****   if ((currEv & SL_ZCS_EVENT_ALL_DN) != 0) {
  87:rt_i32zcfcn.c ****     zcEvent = FALLING_ZCEVENT;
  88:rt_i32zcfcn.c ****   } else if ((currEv & SL_ZCS_EVENT_ALL_UP) != 0) {
  89:rt_i32zcfcn.c ****     zcEvent = RISING_ZCEVENT;
  90:rt_i32zcfcn.c ****   } else {
  91:rt_i32zcfcn.c ****     zcEvent = NO_ZCEVENT;
  92:rt_i32zcfcn.c ****   }
  93:rt_i32zcfcn.c **** 
  94:rt_i32zcfcn.c ****   return zcEvent;
  80              		.loc 1 94 3 is_stmt 1 view .LVU18
  95:rt_i32zcfcn.c **** }                                      /* rt_I32ZCFcn */
  81              		.loc 1 95 1 is_stmt 0 view .LVU19
  82 002a 10BD     		pop	{r4, pc}
  83              	.LVL8:
  84              	.L26:
  77:rt_i32zcfcn.c ****     currEv = (slZcEventType)(slZcUnAliasEvents(prevEv, currEv));
  85              		.loc 1 77 3 is_stmt 1 discriminator 4 view .LVU20
  77:rt_i32zcfcn.c ****     currEv = (slZcEventType)(slZcUnAliasEvents(prevEv, currEv));
  86              		.loc 1 77 7 is_stmt 0 discriminator 4 view .LVU21
  87 002c 134C     		ldr	r4, .L29+4
  88              	.LVL9:
  77:rt_i32zcfcn.c ****     currEv = (slZcEventType)(slZcUnAliasEvents(prevEv, currEv));
  89              		.loc 1 77 7 discriminator 4 view .LVU22
  90 002e 205C     		ldrb	r0, [r4, r0]	@ zero_extendqisi2
  91              	.LVL10:
  77:rt_i32zcfcn.c ****     currEv = (slZcEventType)(slZcUnAliasEvents(prevEv, currEv));
  92              		.loc 1 77 6 discriminator 4 view .LVU23
  93 0030 0342     		tst	r3, r0
  94 0032 F8D0     		beq	.L3
  78:rt_i32zcfcn.c ****   } else {
  95              		.loc 1 78 14 view .LVU24
  96 0034 1CF0080F 		tst	ip, #8
  45:rt_i32zcfcn.c ****   const slZcSignalSignType prevSign = (slZcSignalSignType)(((uint8_T)(*prevZc))
  97              		.loc 1 45 23 view .LVU25
  98 0038 4FEA9C00 		lsr	r0, ip, #2
  78:rt_i32zcfcn.c ****   } else {
  99              		.loc 1 78 5 is_stmt 1 view .LVU26
  78:rt_i32zcfcn.c ****   } else {
 100              		.loc 1 78 14 is_stmt 0 view .LVU27
 101 003c 11D1     		bne	.L27
  78:rt_i32zcfcn.c ****   } else {
 102              		.loc 1 78 30 discriminator 3 view .LVU28
 103 003e C406     		lsls	r4, r0, #27
 104 0040 01D5     		bpl	.L6
 105              	.L28:
  78:rt_i32zcfcn.c ****   } else {
 106              		.loc 1 78 30 discriminator 6 view .LVU29
 107 0042 9806     		lsls	r0, r3, #26
 108 0044 EFD4     		bmi	.L3
 109              	.L6:
 110              	.LVL11:
  84:rt_i32zcfcn.c ****   *prevZc = (ZCSigState)((currSign) | (tempEv));
 111              		.loc 1 84 3 is_stmt 1 view .LVU30
  85:rt_i32zcfcn.c ****   if ((currEv & SL_ZCS_EVENT_ALL_DN) != 0) {
 112              		.loc 1 85 3 view .LVU31
  85:rt_i32zcfcn.c ****   if ((currEv & SL_ZCS_EVENT_ALL_DN) != 0) {
 113              		.loc 1 85 13 is_stmt 0 view .LVU32
 114 0046 42EA8302 		orr	r2, r2, r3, lsl #2
 115              	.LVL12:
  86:rt_i32zcfcn.c ****     zcEvent = FALLING_ZCEVENT;
 116              		.loc 1 86 6 view .LVU33
 117 004a 13F0380F 		tst	r3, #56
  85:rt_i32zcfcn.c ****   if ((currEv & SL_ZCS_EVENT_ALL_DN) != 0) {
 118              		.loc 1 85 11 view .LVU34
 119 004e 0A70     		strb	r2, [r1]
  86:rt_i32zcfcn.c ****     zcEvent = FALLING_ZCEVENT;
 120              		.loc 1 86 3 is_stmt 1 view .LVU35
  87:rt_i32zcfcn.c ****   } else if ((currEv & SL_ZCS_EVENT_ALL_UP) != 0) {
 121              		.loc 1 87 13 is_stmt 0 view .LVU36
 122 0050 18BF     		it	ne
 123 0052 4FF0FF30 		movne	r0, #-1
  86:rt_i32zcfcn.c ****     zcEvent = FALLING_ZCEVENT;
 124              		.loc 1 86 6 view .LVU37
 125 0056 E8D1     		bne	.L7
  88:rt_i32zcfcn.c ****     zcEvent = RISING_ZCEVENT;
 126              		.loc 1 88 13 view .LVU38
 127 0058 13F00700 		ands	r0, r3, #7
 128 005c 18BF     		it	ne
 129 005e 0120     		movne	r0, #1
  88:rt_i32zcfcn.c ****     zcEvent = RISING_ZCEVENT;
 130              		.loc 1 88 10 is_stmt 1 view .LVU39
 131              	.LVL13:
  94:rt_i32zcfcn.c **** }                                      /* rt_I32ZCFcn */
 132              		.loc 1 94 3 view .LVU40
 133              		.loc 1 95 1 is_stmt 0 view .LVU41
 134 0060 10BD     		pop	{r4, pc}
 135              	.LVL14:
 136              	.L27:
  78:rt_i32zcfcn.c ****   } else {
 137              		.loc 1 78 30 discriminator 2 view .LVU42
 138 0062 5C07     		lsls	r4, r3, #29
 139 0064 DFD4     		bmi	.L3
  78:rt_i32zcfcn.c ****   } else {
 140              		.loc 1 78 30 view .LVU43
 141 0066 C406     		lsls	r4, r0, #27
 142 0068 EDD5     		bpl	.L6
 143 006a EAE7     		b	.L28
 144              	.LVL15:
 145              	.L25:
  50:rt_i32zcfcn.c ****     SL_ZCS_SIGN_POS :
 146              		.loc 1 50 39 discriminator 1 view .LVU44
 147 006c 9217     		asrs	r2, r2, #30
 148              	.LVL16:
  50:rt_i32zcfcn.c ****     SL_ZCS_SIGN_POS :
 149              		.loc 1 50 39 discriminator 1 view .LVU45
 150 006e 02F00202 		and	r2, r2, #2
  55:rt_i32zcfcn.c **** 
 151              		.loc 1 55 47 discriminator 1 view .LVU46
 152 0072 9646     		mov	lr, r2
 153 0074 CEE7     		b	.L2
 154              	.L30:
 155 0076 00BF     		.align	2
 156              	.L29:
 157 0078 00000000 		.word	eventMatrix.0
 158 007c 00000000 		.word	CSWTCH.3
 159              		.cfi_endproc
 160              	.LFE0:
 162              		.section	.rodata.CSWTCH.3,"a"
 163              		.align	2
 166              	CSWTCH.3:
 167 0000 38       		.byte	56
 168 0001 3F       		.byte	63
 169 0002 07       		.byte	7
 170              		.section	.rodata.eventMatrix.0,"a"
 171              		.align	2
 174              	eventMatrix.0:
 175 0000 00042000 		.ascii	"\000\004 \000"
 176 0004 10000800 		.ascii	"\020\000\010\000"
 177 0008 02010000 		.ascii	"\002\001\000\000"
 178 000c 00000000 		.ascii	"\000\000\000\000"
 179              		.text
 180              	.Letext0:
 181              		.file 2 "rtwtypes.h"
 182              		.file 3 "zero_crossing_types.h"
 183              		.file 4 "C:\\PROGRA~1\\MATLAB\\R2023a\\simulink\\include/solver_zc.h"
DEFINED SYMBOLS
                            *ABS*:00000000 rt_i32zcfcn.c
C:\Users\luukr\AppData\Local\Temp\cctvsK3e.s:20     .text.rt_I32ZCFcn:00000000 $t
C:\Users\luukr\AppData\Local\Temp\cctvsK3e.s:27     .text.rt_I32ZCFcn:00000000 rt_I32ZCFcn
C:\Users\luukr\AppData\Local\Temp\cctvsK3e.s:157    .text.rt_I32ZCFcn:00000078 $d
C:\Users\luukr\AppData\Local\Temp\cctvsK3e.s:174    .rodata.eventMatrix.0:00000000 eventMatrix.0
C:\Users\luukr\AppData\Local\Temp\cctvsK3e.s:166    .rodata.CSWTCH.3:00000000 CSWTCH.3
C:\Users\luukr\AppData\Local\Temp\cctvsK3e.s:163    .rodata.CSWTCH.3:00000000 $d
C:\Users\luukr\AppData\Local\Temp\cctvsK3e.s:171    .rodata.eventMatrix.0:00000000 $d

NO UNDEFINED SYMBOLS
